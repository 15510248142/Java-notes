## 分库分表

- 一种常见的路由策略如下：

  - > １、中间变量　＝ user_id%（库数量*每个库的表数量）;
    >
    > ２、库序号　＝　取整（中间变量／每个库的表数量）;
    >
    > ３、表序号　＝　中间变量％每个库的表数量;





## 执行计划

- explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化

- type

  - 查询时的访问方式，性能：all < index < range < index_merge < ref_or_null < ref < eq_ref < systemconst

  - ```sql
        ALL             全表扫描，对于数据表从头到尾找一遍
                        select * from tb1;
                        特别的：如果有limit限制，则找到之后就不在继续向下扫描
                               select * from tb1 where email = 'seven@live.com'
                               select * from tb1 where email = 'seven@live.com' limit 1;
                               虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。
    
        INDEX           全索引扫描，对索引从头到尾找一遍
                        select nid from tb1;
    
        RANGE          对索引列进行范围查找
                        select *  from tb1 where name < 'alex';
                        PS:
                            between and
                            in
                            >   >=  <   <=  操作
                            注意：!= 和 \> 符号
    
        INDEX_MERGE     合并索引，使用多个单列索引搜索
                        select *  from tb1 where name = 'alex' or nid in (11,22,33);
    
        REF             根据索引查找一个或多个值
                        select *  from tb1 where name = 'seven';
    
        EQ_REF          连接时使用primary key 或 unique类型
                        select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid;
    
        CONST           常量
                        表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。
                        select nid from tb1 where nid = 2 ;
    
        SYSTEM          系统
                        表仅有一行(=系统表)。这是const联接类型的一个特例。
                        select * from (select nid from tb1 where nid = 1) as A;
    ```





## BTree索引

- 数据库的操作
  - 除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，比如安全、性能、用户体验等等。限于专栏要讨论的主要是数据结构和算法，对于非功能性需求，我们着重考虑**性能方面**的需求。性能方面的需求，我们主要考察时间和空间两方面，也就是**执行效率和存储空间**。
  - 在执行效率方面，我们希望通过索引，查询数据的效率尽可能的高；在存储空间方面，我们希望索引不要消耗太多的内存空间。
    - 我们先来看**散列表**。散列表的查询性能很好，时间复杂度是 O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。
    - 我们再来看**平衡二叉查找树**。尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。
    - 我们再来看**跳表**。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。
- B-Tree
  - 数据结构
    - d为大于1的一个正整数，称为B-Tree的度。
    - h为一个正整数，称为B-Tree的高度。
    - 每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d。
    - 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。
    - 所有叶节点具有相同的深度，等于树高h。
    - key和指针互相间隔，节点两端是指针。
    - 一个节点中的key从左到右非递减排列。
- B+Tree
  - 它是通过二叉查找树演化过来的
    - 树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。
    - 比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？
    - 我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。
    - 不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。
    - 数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。
  - 特点：
    - 每个节点中子节点的个数不能超过 m，也不能小于 m/2；
    - 根节点的子节点个数可以不超过 m/2，这是一个例外；
    - m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；
    - 通过链表将叶子节点串联在一起，这样可以方便按区间查找；
    - 一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。
  - 内节点不存储data，只存储key；叶子节点不存储指针
  - 虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间
    - B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；
    - B 树中的叶子节点并不需要链表来串联。
- 为什么使用B-Tree（B+Tree）
  - 局部性原理与磁盘预读
    - 当一个数据被用到时，其附近的数据也通常会马上被使用
    - 预读的长度一般为页（page）的整倍数
- B-/+Tree索引的性能分析
  - 一次检索最多需要h-1次I/O
    - 一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）
  - B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能
- 使用自增字段作为主键则是一个很好的选择
  - 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

- java中linkedHashMap就是链表链表+HashMap的组合，用于实现缓存的lru算法比较方便，不过要支持区间查询需要在插入时维持链表的有序性，复杂度O(n).效率比跳表和b+tree差



## MySQL语句执行顺序

- 写的顺序：select ... from... where.... group by... having... order by.. limit [offset,] 
- 顺序
  - from
  - on
  - join
  - where
  - group by
  - having
  - select
  - distinct
  - order by
  - limit


## JVM调优案例分析与实践

- 常用命令

  - 两种方式都可以查看tomcat进程号
    - ps -ef | grep java
    - jps -lmvV |grep java
  - 查看进程内线程情况	
    - 找到占用cpu时间最长的进程号:2565	
    - top -Hp 2556（2556为上一步查询出来的进程号）	
  - 得到线程号的十六进制数
    - printf "%x\n" 2565（输出为a05）
  - 使用jstack定位问题
    - jstack 21711 | grep a05
  - 查看内存和swap使用情况
    - free -h   		
    - 可以把free的输出看成一个二维数组FO(Free Output)。
    - free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free）

- 内存和SWAP问题

  - swap全称为swap place，即交换区，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真实内存中。
  - 系统稳定运行，偶尔发生响应超时的情况。查看下游依赖服务和数据库状态都良好。超时完全是由于服务本身问题造成的。重启不能解决问题，一直会间隔性的发生超时
  - 原因分析
    - 系统内存够用(JVM内存未使用到SWAP内存)，但JVM内存不够，最终导致JVM的频繁垃圾回收（FGC），严重影响性能 (stop the word)
      - 增大JVM内存，但有可能导致第二种情况的问题出现
      - 如果机器资源充足，建议把影响的业务独立拆分，分开部署
      - 如果机器资源不是很充足，只能进行代码的优化了
    - 系统内存不够，把JVM堆部分用到了SWAP，那么此时的垃圾回收需要把SWAP的内存换回到系统物理内存再进行JVM的垃圾回收。最大影响，导致每次GC的时间变得很久
      - 增大系统内存，但是有最大物理内存的限制。一般每个虚拟机的系统内存是固定分配的
      - 分析导致占用内存过大的原因，进行程序优化
    - 物理内存不够用， 大量JVM的堆内存被交换到SWAP后，垃圾回收时，把SWAP内存换回物理内存，但SWAP的内存又不会立即回， 此时可以观察到垃圾回收同时swap使用的内存会变大(其它部分内存要交换到SWAP里)
      - 增大物理内存。
      - 分析导致占用内存过大的原因，进行程序优化。或进行服务的拆分
    - 进程因为内存问题而被系统杀掉。开启SWAP分区，可以有效防止进程因为内存问题而被系统杀掉

  

## 频繁发生FULLGC原因

- 老年代空间不足
  - 大对象直接进入老年代、长期存活的对象进入老年代等。
    - 对象在Eden出生，经过第一次Minor GC后依然存活，并且能被Survival容纳的话，将被移动到Survival，对象年龄设为1
    - 对象在Survival中每熬过一次Major GC，年龄就增加1，达到一定程度（默认是15），就会被晋升到老年代。
    - 对象晋升老年代的阈值，可以通过参数-XX:MaxTenuringThreShold 指定
  - 可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间
- 空间分配担保失败
  - 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。 
  - 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
  - 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。
- Concurrent Mode Failure
  - 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足 （可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足）， 便会报 Concurrent Mode Failure 错误，并触发 Full GC。

- 定位 Full GC 发生的原因
  - 首先通过printgcdetail 查看fullgc频率以及时长，以及回收前和回收后老年代回收了多少垃圾
    - 如果回收的垃圾很多，比如 80%->20% 考虑业务是否有可以优化的地方，是否有同类型对象短时间大量过期，可以在内存高位执行 dump 然后等full gc 后再dump做对比
    - 如果回收的垃圾比较少，执行dump，查看哪些对象占用了大部分空间，是不是发生了内存泄露，引用都被哪些对象持有，是否应该及时释放等。
  - 通过dump 查看内存中哪些对象多，这些可能是引起fullgc的原因，看是否能优化
    - 如果堆太大dump不现实,jmap 查看线上堆栈占用情况 排序分析占比较多对象。 缩小问题范围
    - 
  - 如果堆大或者是生产环境，可以开起jmc 飞行一段时间，查看这期间的相关数据来订位问题



## 垃圾回收

- Java 定义的不同可达性级别（reachability level），具体如下：

  - 强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。
  - 软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。
  - 弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。
  - 幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。

- 在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。

  - 强引用特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。  
  - 软引用特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象  
    - 应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
  - 弱引用特点：弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。  
    - 应用场景：弱应用同样可用于内存敏感的缓存。
  - 虚引用特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。  
    - 应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。

- 可达性分析算法

  - 将一系列 GCRoots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

  - 一般而言，GC Roots 包括（但不限于）如下几种：

    - Java 方法栈桢中的局部变量；

    2. 已加载类的静态变量；
    3. JNI handles；
    4. 已启动且未停止的 Java 线程。

- Stop-the-world 以及安全点

  - Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）
  - 安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。
    4. 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。
    5. 只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。
  - 除了执行 JNI 本地代码外，Java 线程还有其他几种状态
    - 解释执行字节码
      4. 对于解释执行来说，字节码与字节码之间皆可作为安全点
      5. 当有安全点请求时，执行一条字节码便进行一次安全点检测。
    - 执行即时编译器生成的机器码
      4. HotSpot 虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测
      5. 即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。
    - 线程阻塞
      4. 阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点
      5. 其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点

  4. 除了垃圾回收之外，Java 虚拟机其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制

- 垃圾回收的三种方式

  - 第一种是清除（sweep）

    4. 把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表

    - 两个缺点。一是会造成内存碎片，另一个则是分配效率较低。
      4. 标记和回收这两个过程的效率都不算太高；其次，因为需要回收的对象不一定是连续的（实际上往往都不是），因此会产生很多内存碎片

  - 第二种是压缩（compact）

    4. 把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间，
    5. 解决内存碎片化的问题，代价是压缩算法的性能开销。

  - 第三种则是复制（copy）

    4. 把内存区域分为两等分，分别用两个指针 from 和 to 来维护
    5. 复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。
    6. HotSpot默认的Eden和Survivor比例是8:1:1，就是说，每次能使用90%的内存容量。当然，也可能会出现剩余10%的Survivor空间不够复制原有存活对象的情况，那就需要依赖其它内存（这里指老年代）进行分配担保（Handle Promotion)。通过分配担保机制，这些对象会直接进入老年代

- Java 虚拟机的堆划分

  - 每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的TLAB。
    4. 需要维护两个指针（实际上可能更多，但重要也就两个），一个指向TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾
    5. 接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。
    6. 如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，需要当前线程重新申请新的 TLAB
  - Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次
    4. 如果一个对象被复制的次数为15，那么该对象将被晋升（promote）至老年代。如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。
    5. 当发生 Minor GC 时，我们应用了标记 - 复制算法。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。
    6. Minor GC 的另外一个好处是不用对整个堆进行垃圾回收
  - Mirnor GC来讲它的耗时主要由两个因素决定:
    4. 复制活跃对象的时间
    5. 扫描card table(老年代对象引用新生代对象)的时间

- 卡表

  - 该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

  - 在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。

  - 如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

  - 在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障

    - （write barrier，注意不要和 volatile 字段的写屏障混淆）
    - CARD_TABLE [this address >> 9] = DIRTY;(这里右移 9 位相当于除以 512，Java 虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。)

  - 在高并发环境下，写屏障又带来了伪共享问题

    - 在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节（1KB= 1024字节）的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡（一个卡表项占1个字节），也就是 32KB（64*512=32KB） 的内存。

    - 如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。

    - 一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为dirty。

      - if (CARD_TABLE [this address >> 9] != 0)

        CARD_TABLE [this address >> 9] = 0;







## 垃圾回收器

- 最主流的 Oracle JDK

  - Serial GC

    - 它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。
    - 从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。
    - -XX:+UseSerialGC

  - ParNew GC

    - 很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作
    - -XX:+UseConcMarkSweepGC -XX:+UseParNewGC

  - CMS（Concurrent Mark Sweep） GC

    - 基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。
    - 但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。
    - 另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。

  - Parrallel GC

    - 在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。

    - 它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。

    - 另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整

      - -XX:MaxGCPauseMillis=value

        -XX:GCTimeRatio=N // GC 时间和用户时间比例 = 1 / (N+1)

  - G1 GC 

    - 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。
    - G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。
      G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。

- 垃圾收集过程

  - 第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间。
  - 第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。
  - 第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：-XX:MaxTenuringThreshold=<N>
  - 后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。





## CMS

- 以获取最短回收停顿时间为目标的收集器，尤其重视服务的响应速度。

- CMS收集器仅作用于**老年代**的收集，是基于`标记-清除算法`的，它的运作过程分为4个步骤：
  - 初始标记（CMS initial mark）
  - 并发标记（CMS concurrent mark）
  - 重新标记（CMS remark）
  - 并发清除（CMS concurrent sweep）
- 其中，`初始标记`、`重新标记`这两个步骤仍然需要Stop-the-world。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。
- 三个比较明显的缺点
- CMS收集器对CPU资源非常敏感。垃圾回收时会占用一部分线程，导致系统变慢，总吞吐量会降低。
  - 无法处理浮动垃圾，需要预留足够的内存空间给用户线程使用
  - 通过 -XX:CMSInitiatingOccupancyFraction 参数控制触发垃圾回收的阈值。
  - 标记-清除，容易产生内存碎片
  - XX:+UseCMSCompactAtFullColletion 开启碎片整理功能，默认开启
    - -XX:CMSFullGCsBeforeCompaction，控制多少次不压缩的FullGC之后来一次带压缩的





## G1

- G1具备如下特点：

- **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过**并发**的方式让Java程序继续运行。

  - 分代收集

    - 在新生代，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World 的暂停。
    - 在老年代，大部分情况下都是并发标记，而整理（Compact）则是和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行的。

  - 空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于**标记-整理算法**实现的收集器，从局部（两个Region之间）上来看是基于“**复制**”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。**这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC**。

  - 可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。

  - region 的大小是一致的，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region，这点可以从源码[heapRegionBounds.hpp](http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp)中看到。当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。

    在 G1 实现中，年代是个逻辑概念，具体体现在，一部分 region 是作为 Eden，一部分作为 Survivor，除了意料之中的 Old region，G1 会将超过 region 50% 大小的对象（在应用中，通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中。逻辑上，Humongous region 算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代 GC 的复制算法。

  - G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。

- region 设计有什么副作用

  - region 大小和大对象很难保证一致，这会导致空间的浪费。

  - egion 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况，请参考[OpenJDK 社区的讨论](http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2017-November/002726.html)。这本质也可以看作是 JVM 的 bug，尽管解决办法也非常简单，直接设置较大的 region 大小

      - > -XX:G1HeapRegionSize=<N, 例如 16>M

- **G1收集的运作过程大致如下：**

  - **初始标记（Initial Marking）**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，**这阶段需要停顿线程，但耗时很短**。
  - **并发标记（Concurrent Marking）**：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，**这阶段耗时较长**，但可与用户程序并发执行。
  - **最终标记（Final Marking）**：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，**这阶段需要停顿线程，但是可并行执行**。
  - **筛选回收（Live Data Counting and Evacuation）**：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

- 习惯上人们喜欢把新生代 GC（Young GC）叫作 Minor GC，老年代 GC 叫作 Major GC，区别于整体性的 Full GC。但是现代 GC 中，这种概念已经不再准确，对于 G1 来说

  - Minor GC 仍然存在，虽然具体过程会有区别，会涉及 Remembered Set 等相关处理。

  - 老年代回收，则是依靠 Mixed GC。并发标记结束后，JVM 就有足够的信息进行垃圾收集，Mixed GC 不仅同时会清理 Eden、Survivor 区域，而且还会清理部分 Old 区域。可以通过设置下面的参数，指定触发阈值，并且设定最多被包含在一次 Mixed GC 中的 region 比例。

    > - –XX:G1MixedGCLiveThresholdPercent
    > - –XX:G1OldCSetRegionThresholdPercent

- Remembered Set

  - card table是remembered set的一种实现
  - 用于记录和维护 region 之间对象的引用关系。为什么需要这么做呢？试想，新生代 GC 是复制算法，也就是说，类似对象从 Eden 或者 Survivor 到 to 区域的“移动”，其实是“复制”，本质上是一个新的对象。在这个过程中，需要必须保证老年代到新生代的跨区引用仍然有效
  - G1 的很多开销都是源自 Remembered Set，例如，它通常约占用 Heap 大小的 20% 或更高，这可是非常可观的比例。并且，我们进行对象复制的时候，因为需要扫描和更改 Card Table 的信息，这个速度影响了复制的速度，进而影响暂停时间。

- G1 行为变化

  - 上面提到了 Humongous 对象的分配和回收，这是很多内存问题的来源，Humongous region 作为老年代的一部分，通常认为它会在并发标记结束后才进行回收，但是在新版 G1 中，Humongous 对象回收采取了更加激进的策略。
  - 我们知道 G1 记录了老年代 region 间对象引用，Humongous 对象数量有限，所以能够快速的知道是否有老年代对象引用它。如果没有，能够阻止它被回收的唯一可能，就是新生代是否有对象引用了它，但这个信息是可以在 Young GC 时就知道的，所以完全可以在 Young GC 中就进行 Humongous 对象的回收，不用像其他老年代对象那样，等待并发标记结束。





## 为什么在标记垃圾的时候，需要stop the world

- 以cms为例，它有不同的mark： initial mark，conc mark， remark；conc时候不需要stw；其他需要短暂stw，这样引用关系才不变，另外效率也高
- 是为了避免在标记的时候又有对象在堆内生成，如果这个对象对其他未标记对象有引用，而这个时候由于gc而清理掉了未标记的对象，会有问题







## GC调优思路

- 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput）

- 基本的调优思路可以总结为

  - **理解应用需求和问题，确定调优目标**。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。

    - 参照以上G1中的参数调优

  - **掌握 JVM 和 GC 的状态，定位具体的问题**，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。

    - > 除了常用的两个选项
      >
      > -XX:+PrintGCDetails
      >
      > -XX:+PrintGCDateStamps
      >
      > 
      >
      > 还有一些非常有用的日志选项，很多特定问题的诊断都是要依赖这些选项
      >
      > -XX:+PrintAdaptiveSizePolicy // 打印 G1 Ergonomics 相关信息
      >
      > 我们知道 GC 内部一些行为是适应性的触发的，利用 PrintAdaptiveSizePolicy，我们就可以知道为什么 JVM 做出了一些可能我们不希望发生的动作。例如，G1 调优的一个基本建议就是避免进行大量的 Humongous 对象分配，如果 Ergonomics 信息说明发生了这一点，那么就可以考虑要么增大堆的大小，要么直接将 region 大小提高。
      >
      > 
      >
      > 如果是怀疑出现引用清理不及时的情况，则可以打开下面选项，掌握到底是哪里出现了堆积
      >
      > -XX:+PrintReferenceGC
      >
      > 
      >
      > 另外，建议开启选项下面的选项进行并行引用处理。
      >
      > -XX:+ParallelRefProcEnabled
      >
      > 
      >
      > 需要注意的一点是，JDK 9 中 JVM 和 GC 日志机构进行了重构，其实我前面提到的**PrintGCDetails 已经被标记为废弃**，而**PrintGCDateStamps 已经被移除**，指定它会导致 JVM 无法启动。可以使用下面的命令查询新的配置参数。
      >
      > java -Xlog:help
      >
      > 

  - 这里需要思考，**选择的 GC 类型是否符合我们的应用特征**，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。

    - > 如果发现 Young GC 非常耗时，这很可能就是因为新生代太大了，我们可以考虑减小新生代的最小比例。
      >
      > 
      >
      > -XX:G1NewSizePercent
      >
      > 降低其最大值同样对降低 Young GC 延迟有帮助。
      >
      > 
      >
      > -XX:G1MaxNewSizePercent

    - > 如果是 Mixed GC 延迟较长，我们应该怎么做呢
      >
      > 
      >
      > 部分 Old region 会被包含进 Mixed GC，减少一次处理的 region 个数，就是个直接的选择之一。
      > 我在上面已经介绍了 G1OldCSetRegionThresholdPercent 控制其最大值，还可以利用下面参数提高 Mixed GC 的个数，当前默认值是 8，Mixed GC 数量增多，意味着每次被包含的 region 减少。
      >
      > -XX:G1MixedGCCountTarget

  - 通过**分析确定具体调整的参数或者软硬件配置**。

  - 验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。


























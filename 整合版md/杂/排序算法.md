 排序算法经过长时间演变，大体可以分为两类：内排序和外排序。在排序过程中，全部记录存放在内存，则成为内排序；如果排序过程中需要使用外存，则称为外排序，本文讲的都属于内排序。

内排序有可以分为以下几类：

​    （1）插入排序：直接插入排序、二分法插入排序、希尔排序

​    （2）选择排序：直接选择排序、堆排序

​    （3）交换排序：冒泡排序、快速排序

​    （4）归并排序

​    （5）基数排序

| 排序方法     | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 | 复杂性 |
| ------------ | ---------------- | ---------------- | ---------------- | ---------- | ------ | ------ |
| 直接插入排序 | O(n2)            | O(n2)            | O(n)             | O(1)       | 稳定   | 简单   |
| 希尔排序     | O(nlog2n)        | O(n2)            | O(n1.3)          | O(1)       | 不稳定 | 较复杂 |
| 直接选择排序 | O(n2)            | O(n2)            | O(n2)            | O(1)       | 不稳定 | 简单   |
| 堆排序       | O(nlog2n)        | O(nlog2n)        | O(nlog2n)        | O(1)       | 不稳定 | 较复杂 |
| 冒泡排序     | O(n2)            | O(n2)            | O(n)             | O(1)       | 稳定   | 简单   |
| 快速排序     | O(nlog2n)        | O(n2)            | O(nlog2n)        | O(nlog2n)  | 不稳定 | 较复杂 |
| 归并排序     | O(nlog2n)        | O(nlog2n)        | O(nlog2n)        | O(n)       | 稳定   | 较复杂 |
| 基数排序     | O(d(n+r))        | O(d(n+r))        | O(d(n+r))        | O(n+r)     | 稳定   | 较复杂 |

# **一、插入排序**

•思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。 
•关键问题：在前面已经排好序的序列中找到合适的插入位置。 
•方法： 
    直接插入排序

- 插入排序的最好情况是数组已经有序，此时只需要进行n-1次比较，时间复杂度为O(n)
- 最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）
- 平均来说插入排序算法的复杂度为O(n2)
- 空间复杂度上，直接插入法是就地排序，空间复杂度为(O(1))

​    二分插入排序 

- 最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O(n2)
- 最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)
- 平均情况：O(n2)
- 空间复杂度上，二分插入也是就地排序，空间复杂度为(O(1))。

​    希尔排序

- 增量排序的时间复杂度依赖于所取增量序列的函数，但是到目前为止还没有一个最好的增量序列.有人在大量的实验后得出结论;当n在某个特定的范围后希尔排序的比较和移动次数减少至n^1.3 不管增量序列如何取值，都应该满足最后一个增量值为1。
- 有文献指出，当增量序列为d[k]=2^(t-k+1)时，希尔排序的时间复杂度为O(n^1.5), 其中t为排序趟数。
- 空间复杂度上，二分插入也是就地排序，空间复杂度为(O(1))。

## 1.直接插入排序

(1)基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。（是一种最简单的排序方法，其基本操作是将一条记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表。）

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331175735217-849325726.jpg)

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331192727473-1620564641.gif)

(3)实现 

```java
void insertion_sort(int arr[], int length)
{
    int i,j;
    for (i = 1; i < length; i++) {
        int tmp = arr[i];
        for (j = i; j > 0 && arr[j - 1] > tmp; j--) {
            arr[j] = arr[j - 1];
        }
        arr[j] = tmp;
    }
}

```



 

## 2.二分插入排序

(1)基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里是按二分法找到合适的位置，可以减少比较的次数。

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331190617942-936968861.jpg)

(3)实现

![img](https://images0.cnblogs.com/blog2015/714364/201505/162313329544293.png)

 

## 3.希尔排序

(1)基本思想：希尔排序又叫“缩小增量排序”，先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序，然后取第二个增量d2。其是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331193218622-871635550.png)

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331194038394-815950843.gif)

(3)实现

```java
int shellSort(int arr[], int n) 
{ 
    for (int gap = n/2; gap > 0; gap /= 2) 
    { 
        for (int i = gap; i < n; i += 1) 
        { 
            int temp = arr[i]; 
            int j;             
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) 
                arr[j] = arr[j - gap]; 
            arr[j] = temp; 
        } 
    } 
    return 0; 
}
```

 

# **二、选择排序**

•思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。 
•关键问题：在剩余的待排序记录序列中找到最小关键码记录。 
•方法： 
    **直接选择排序** 

- 选择排序第一轮内循环比较n-1次，然后是n-2次、n-3次........最后一轮内循环比较1次，共(n-1)+(n-2)+....+3+2+1=(n-1+1)n/2=n^2/2，其时间复杂度为O(n2)
- 空间复杂度就是在交换元素时那个临时变量所占的内存空间，空间复杂度为O(1)

​    **堆排序**

- 堆排序的时间复杂度主要由两部分组成：初始化建堆和每次弹出堆顶元素后重新建堆的过程
- 初始化建堆过程的时间复杂度O(n)：假设堆的高度为k，则从倒数第二层右边的节点开始，这一层的节点都要进行子节点比较然后选择是否交换，倒数第三层类似，一直到第一层(即层数从k-1到1)；那么总的时间为(2^(i-1))*(k-i)，其中i表示第i层(范围是k-1到1)，2^(i-1)表示该层上有多少元素，(k-i)表示子树上要比较的次数，即S = 2^(k-2)*1 + 2^(k-3)*2 + 2^(k-4)*3 + ... + 2^1*(k-2) + 2^0*(k-1)，使用错位相减法(用常数2来辅助转换，两边都乘以2再减去原等式)得到S = 2^(K-1) + 2^(K-2) + 2^(K-3) + ... + 2 - (K-1)，忽略最后一项常数项就是等比数列，即S=2^k-2-(k-1)=2^k-k-1，又因为k为完全二叉树的深度，所以有 2^k <= n < 2^k-1，可以认为k = logn，综上所述S = n - logn -1，所以时间复杂度为O(n)
- 弹出堆顶元素后重建堆过程的时间复杂度O(nlogn)：循环n-1次，每次都从跟节点往下循环查找所以每一次时间都是logn，总时间为(n-1)*logn = nlogn - logn
- 故堆排序的时间复杂度为O(n) + O(nlogn) = O(nlogn)
- 堆排序是接地排序，所以空间复杂度为常数O(1)

 

## 1.直接选择排序 

(1)基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331203729814-1036465869.gif)![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331203657208-957544796.gif)

(3)实现

```java

    public static void selectSort(int [] arr,int n){
        for (int i = 0; i < n - 1; i++) {
            int index = i;
            int j;
            // 找出最小值得元素下标
            for (j = i + 1; j < n; j++) {
                if (arr[j] < arr[index]) {
                    index = j;
                }
            }

            int tmp = arr[index];
            arr[index] = arr[i];
            arr[i] = tmp;
            System.out.println(Arrays.toString(arr));
        }

    }

}

```



 

## 2.堆排序 

(1)基本思想： 

　　堆排序是一种树形选择排序，是对直接选择排序的有效改进。

　　堆的定义下：具有n个元素的序列 （h1,h2,…,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。 （可以延伸到前序遍历、中序遍历、后序遍历）



(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331192449971-711145957.gif)

(3)实现

根据堆排序的思想不难得知堆排序核心由两部分组成，即“建堆”和“调整堆”，因此代码主要包括这两个过程的定义

> 最大堆中的最大元素值出现在根结点（堆顶）
>
> 堆中每个父节点的元素值都大于等于其孩子结点

- 堆排序的基本步骤（以升序排序为例）：
  1.初建堆：将一个无序序列进行调整使其满足大根堆的条件
  2.重建堆：去掉最大元之后重建堆（重复1），得到次大元，直至该堆长度为1

可以看到 0 的子元素为 1 、 2 ， 1 的子元素为 3 ， 4 、 3 的子元素为 7 、 8。
对应关系为：下标为 n 的元素的左子元素下标为 2n+1 , 右子元素下标为 2n+2 。根据该对应关系，我们可以将数组看作一个满足堆积性质的完全二叉树，借助二叉树的性质来进行排序。

**简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法。**

按堆积性质，堆可以分为 最大堆 和 最小堆：最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子。那么以最大堆为例，处于最大堆的根节点的元素一定是这个堆中的最大值。

**下面仅讨论最大堆：**

我们从最底层节点开始构建最大堆，依次向上。因为每个节点的两棵子树已经被我们构建为了最大堆，所以选择两个子树的根节点及当前节点中的最大值即为以当前节点为根的树中的最大值。

及自下向上构建最大堆时，我们在每一层只需比较根元素及其两个孩子节点即可正确的构建最大堆


```java
// 大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  

// 小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  

// 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

 
public class HeapSort{
	public static void main(String[] args) {
		int[] arr = {55,3,21,58,9,101,43,19,27};
		heapSort(arr);
		for(int i = 0; i < arr.length; i ++) {
			System.out.print(arr[i]+"  ");
		}
	}
    
	public static void heapSort(int[] arr) {
		//将待排序序列初始化成堆
		for(int i = arr.length / 2; i >= 0; i--) {
			HeapAdjust(arr, i, arr.length-1);
		}
		//开始排序
		for(int i = arr.length - 1, temp = 0; i > 0; i--) {
			temp = arr[i];
			arr[i] = arr[0];
			arr[0] = temp;
			HeapAdjust(arr, 0, i);
		}
	}
    
	//对堆进行调整
	public static void HeapAdjust(int[] arr, int parent, int len) {
		//记录父节点的值
		int temp = arr[parent];
		//寻找左孩子节点
		int child = 2 * parent + 1;
		while(child < len) {
			//从左孩子和右孩子节点中选取较大的
			if(child + 1 < len && arr[child+1] > arr[child]) {
				child ++;
			}
			//如果父节点大于两个孩子节点，则不用交换
			if(arr[parent] > arr[child]) {
				break;
			}
			//将父节点与较大的子节点进行交换
			arr[parent] = arr[child];
			parent = child;
			child = 2 * child + 1;
		}
		arr[parent] = temp;
	}
	
}

```



 

# **三、交换排序**

•思想：利用交换元素的位置进行排序，每次两两比较待排序的元素，直到全部排完。 
•关键问题：排序时要厘清需要进行几轮排序。 
•方法： 
    冒泡排序

- 最坏情况：冒泡排序要进行n-1轮排序循环，每轮排序循环中序列都是非正序的，则每轮排序循环中要进行n-i次比较(1<=i<=n-1)，即其外循环执行n-1次，内循环最多执行n次，最少执行1次，由于内循环执行次数是线性的，故内循环平均执行(n+1)/2次，时间复杂度计算为((n-1)(n+1))/2=(-1)/2 ，时间复杂度为O(n2)
- 最好情况：待排序数组本身就是正序的，一轮扫描即可完成排序，此时时间复杂度仅为比较时的时间复杂度，为O(n)
- 平均情况：O(n2)
- 空间复杂度就是在交换元素时那个临时变量所占的内存空间，最优的空间复杂度就是开始元素顺序已经排好了，则空间复杂度为0，最差的空间复杂度就是开始元素逆序排序了，则空间复杂度为O(n)，平均的空间复杂度为O(1) 

​    快速排序

 

- 最好情况：是每轮划分都将待排序列正好分为两部分，那么每部分需要的时间为上一轮的1/2。如果排序n个元素的序列，其递归树深度为[logn]+1即仅需递归logn次，需要总时间为T(n)的话，第一次需要扫描整个序列，做n次比较，然后将序列一分为二，这两部分各自还需要T(n/2)的时间，依次划分下去：T(n) = 2*T(n/2)+n    T(n) = 2*(2*(T(n/4)+n/2)+n = 4*T(n/4)+2n 等等，且T(1) = 0，所以T(n) = n*T(1) + n*logn = O(nlogn)
- 最坏情况：当待排序列为有序序列(正序或倒序)，每次划分后得到的情况是一侧有1个元素，另一侧是其余元素，则最终要进行n-1轮循环，且第i次循环要进行n-i次比较，总比较次数为n-1 + n-2 + ... + 1 = n(n-1)/2，即时间复杂度为O(n2)
- 空间复杂度待补充。。

 

## 1.冒泡排序

(1)基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一轮比较中：首先比较第1个和第2个数，将小数放前，大数放后；然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一轮的步骤，直至全部排序完成。

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331192342502-1494416654.gif)

(3)实现

第一轮比较完成后，确保了最后一个数是数组中最大的一个数，所以第二轮比较时，最后一个数不参与比较；

第二轮比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三轮比较时，最后两个数不参与比较；

依次类推，每一轮需要比较的次数-1；

```java
void bubbleSort(vector<int>& a)
{
      bool swapp = true;
      while(swapp){
        swapp = false;
        for (size_t i = 0; i < a.size()-1; i++) {
            if (a[i]>a[i+1] ){
                a[i] += a[i+1];
                a[i+1] = a[i] - a[i+1];
                a[i] -=a[i+1];
                swapp = true;
            }
        }
    }
}

```





## **2.快速排序** 

(1)基本思想：在数组中找一个支点(任意),经过一趟排序后，支点左边的数都要比支点小，支点右边的数都要比支点大

(2)实例 

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331192223690-96015465.gif) 



(3)实现

> 核心思想：基准值定为最右边，i和j从最左边开始，如果j小于基准值，则i和j交换位置，并且i++，j++。否则i保持不动，j++。最终当j移动到基准值所在位置后，基准值与i交换位置。

![img](https://upload-images.jianshu.io/upload_images/11078906-ef3ff16e97165f29.png?imageMogr2/auto-orient/strip|imageView2/2/w/488/format/webp)

名词解释 -- 稳定性：经过某种排序算法之后，如果相同值的数据，前后顺序没有发生改变，我们就把这种算法叫做稳定的排序算法。

猜想一：基准值从最左边开始是否可以？



![img](https://upload-images.jianshu.io/upload_images/11078906-bd5c07ec87b46f15.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)

猜想一

得出结论：基准值必需是j移动的结尾，因为最终需要一次基准值和i的交换位置

```cpp
    public static void quickSortSingle(int[] arr, int left, int right) {
        if (left > right)
            return;

        int pivot = arr[right];
        int i = 0, j = 0;
        while (j < right) {
            while (j < right && arr[j] <= pivot) {//如果"哨兵"j小于基准值，则"哨兵"i与"哨兵"j交换位置
                swap(arr, i, j);
                i++;
                j++;
            }
            j++;
        }
        //此时"哨兵"j移动到最右侧，基准值与哨兵"i"所在位置的值进行交换
        swap(arr, i, right);

        quickSortSingle(arr, left, i - 1);
        quickSortSingle(arr, i + 1, right);
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```



```java
/**
 * 快速排序演示
 * @author Lvan
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {5, 1, 7, 3, 1, 6, 9, 4};

        quickSort(arr, 0, arr.length - 1);

        for (int i : arr) {
            System.out.print(i + "\t");
        }
    }

    /**
     * @param arr        待排序列
     * @param leftIndex  待排序列起始位置
     * @param rightIndex 待排序列结束位置
     */
    private static void quickSort(int[] arr, int leftIndex, int rightIndex) {
        if (leftIndex >= rightIndex) {
            return;
        }

        int left = leftIndex;
        int right = rightIndex;
        //待排序的第一个元素作为基准值
        int key = arr[left];

        //从左右两边交替扫描，直到left = right
        while (left < right) {
            while (right > left && arr[right] >= key) {
                //从右往左扫描，找到第一个比基准值小的元素
                right--;
            }

            //找到这种元素将arr[right]放入arr[left]中
            arr[left] = arr[right];

            while (left < right && arr[left] <= key) {
                //从左往右扫描，找到第一个比基准值大的元素
                left++;
            }

            //找到这种元素将arr[left]放入arr[right]中
            arr[right] = arr[left];
        }
        //基准值归位
        arr[left] = key;
        //对基准值左边的元素进行递归排序
        quickSort(arr, leftIndex, left - 1);
        //对基准值右边的元素进行递归排序。
        quickSort(arr, right + 1, rightIndex);
    }
}

    public static void quickSortSingle(int[] arr, int left, int right) {
        if (left > right)
            return;

        int pivot = arr[right];
        int i = 0, j = 0;
        while (j < right) {
            while (j < right && arr[j] <= pivot) {//如果"哨兵"j小于基准值，则"哨兵"i与"哨兵"j交换位置
                swap(arr, i, j);
                i++;
                j++;
            }
            j++;
        }
        //此时"哨兵"j移动到最右侧，基准值与哨兵"i"所在位置的值进行交换
        swap(arr, i, right);

        quickSortSingle(arr, left, i - 1);
        quickSortSingle(arr, i + 1, right);
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }



//优化：
//    随机选取基准值base(支点随机选取)
//    配合着使用插入排序(当问题规模较小时，近乎有序时，插入排序表现的很好)
//    当大量数据，且重复数多时，用三路快排


void QuickSort ( int*arr,int low, int high);
int FindPos ( int*arr,int low, int high);


int FindPos ( int*arr,int low, int high)
{
    int val = arr[low];

    while (low < high) {
        while (low < high && arr[high] >= val)
            --high;
        arr[low] = arr[high];
        while (low < high && arr[low] <= val)
            ++low;
        arr[high] = arr[low];
    }
    arr[low] = val;
    return low;
}


void QuickSort ( int arr[], int low, int high)
{
    int pos;
    if (low < high) {
        pos = FindPos(arr, low, high);
        QuickSort(arr, low, pos - 1);//劈两半，左边 
        QuickSort(arr, pos + 1, high); //右边 
    }
    return;
}

int main ()
{
    int arr[ 6]={ 5, 3, -88, 77, 44, -1 } ;
    int i;
    QuickSort(arr, 0, 5);
    for (i = 0; i < 6; i++)
        printf("%d   ", arr[i]);
    printf("\n");
    return 0;
}


```





## 双路快排

> 核心思想：基准值在最左边，“哨兵”i在最左边，“哨兵”j在最右边，从**右边**（*注意要从右边开始，下面会有说明*）先开始（j--），如果“哨兵”j所在的数据小于基准值则停止；“哨兵”i开始（i++），如果“哨兵”i所在的数据大于基准值则停止，i与j交换位置；如果i和j相遇，则基准值与i或j（因为两者现在一致）交换位置。

下面按照上述的规则列出一组数据整个交换流程：



![img](https:////upload-images.jianshu.io/upload_images/11078906-6cc965efd0ef517c.png?imageMogr2/auto-orient/strip|imageView2/2/w/432/format/webp)

双路排序数据交换流程



 猜想二：如果先从左边找会出现什么问题？



![img](https:////upload-images.jianshu.io/upload_images/11078906-530c2f598f7030f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/552/format/webp)

猜想二

 得出结论：因为如果先从右边开始会停留在比基准值大的数上，这时交换基准值的位置就会出现问题，所以开始执行的方向必需是基准值的反方向。

```swift
    public static void quickSortDual(int[] arr, int left, int right) {
        if (left > right)
            return;

        int pivot = arr[left];//基准值
        int i = left;//左侧"哨兵"
        int j = right;//右侧"哨兵"
        while (i != j) {//注意：要从基准值所在侧的另外一侧开始
            while (arr[j] >= pivot && i < j)//如果右侧出现了比基准值小的元素，则"哨兵"j停留
                j--;
            while (arr[i] <= pivot && i < j)//如果左侧出现了比基准值小的元素，则"哨兵"i停留
                i++;
            if (i < j) {//如果"哨兵"i与j没有相遇则交换其所在位置的数据
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
        //此时"哨兵"i与j相遇，交换基准值与该相遇点的数据
        arr[left] = arr[i];
        arr[i] = pivot;

        quickSortDual(arr, left, i - 1);//递归的处理左侧数据
        quickSortDual(arr, i + 1, right);//递归的处理右侧数据
    }
```



## 三路快排

> 核心思想：基准值在最左边，“哨兵”i在基准值右侧加1的位置，“哨兵”j在最右边，从基准值右侧加1的位置开始往后遍历，如果遍历到的当前值小于基准值，则当前值与左侧"哨兵"交换位置，左侧"哨兵"进一，反之，则当前值与右侧"哨兵"交换位置，左侧"哨兵"退一。





 下面按照上述的规则列出一组数据整个交换流程（虽然该数据的排序过程并没有丢失稳定性，但是大家不要认为三路快排是个稳定排序算法）：



![img](https:////upload-images.jianshu.io/upload_images/11078906-e28b9a84965822f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/162/format/webp)

三路排序数据交换流程

代码实现：

```cpp
    public static void quickSortThreeWay(int[] arr, int left, int right) {
        if (left > right)
            return;

        int pivot = arr[left];//基准值
        int i = left;//左侧"哨兵"
        int j = right + 1;//右侧"哨兵"
        int index = left + 1;
        while (index < j) {
            if (arr[index] < pivot) {//如果当前值小于基准值，则当前值与左侧"哨兵"交换位置，左侧"哨兵"进一
                swap(arr, index, i + 1);
                i++;
                index++;
            } else if (arr[index] > pivot) {//如果当前值大于基准值，则当前值与右侧"哨兵"交换位置，左侧"哨兵"退一
                swap(arr, index, j - 1);
                j--;
            } else {
                index++;
            }
        }

        swap(arr, left, i);

        quickSortSingle(arr, left, i - 1);
        quickSortSingle(arr, j, right);
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```



## 三路快速排序

三路快速排序是将数组分成3个部分，小于V，等于V，大于V。

在递归的过程中等于V的部分就不需要进行管理，只需要对小于V和大于V进行管理。

![img](https://img-blog.csdnimg.cn/20190422183616119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzIzNjE1,size_16,color_FFFFFF,t_70)

lt表示小于V的最后一个元素。

gt表示处理后的大于V的第一个元素。

对i元素的情况进行讨论：

**1.e == v：e就纳入等于v的部分中，然后i ++。**

**2.e < v：和等于v的第一个元素进行位置交换，接着维护lt，lt ++，然后i ++，去查看下一个元素e。**

**3.e > v: 和gt-1这个元素进行位置交换，接着gt --，此时的i不需要维护。**

 

当数组出来完成之后为这样：

区间为**前闭后闭。**

![img](https://img-blog.csdnimg.cn/20190422184138396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzIzNjE1,size_16,color_FFFFFF,t_70)

当处理完成之后，就对小于V和大于V的部分进行递归的快速排序即可，而等于V的部分已经放入合适的位置中了。

```java
import java.util.*;
 
public class QuickSort3Ways {
 
    // 递归使用快速排序,对arr[l...r]的范围进行排序
    private static void sort(Comparable[] arr, int l, int r){
 
        // 对于小规模数组, 使用插入排序
        if( r - l <= 15 ){
            InsertionSort.sort(arr, l, r);
            return;
        }
 
        // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
        swap( arr, l, (int)(Math.random()*(r-l+1)) + l );
 
        Comparable v = arr[l];
 
        int lt = l;     // arr[l+1...lt] < v
        int gt = r + 1; // arr[gt...r] > v
        int i = l+1;    // arr[lt+1...i) == v
        while( i < gt ){
            if( arr[i].compareTo(v) < 0 ){
                swap( arr, i, lt+1);
                i ++;
                lt ++;
            } else if( arr[i].compareTo(v) > 0 ){
                swap( arr, i, gt-1);
                gt --;
            } else{ // arr[i] == v
                i ++;
            }
        }
 
        swap( arr, l, lt );
 
        sort(arr, l, lt-1);
        sort(arr, gt, r);
    }
 
    public static void sort(Comparable[] arr){
 
        int n = arr.length;
        sort(arr, 0, n-1);
    }
 
    private static void swap(Object[] arr, int i, int j) {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
 
}
```

 

# **四、归并排序** 

- 时间复杂度：归并排序主要分为拆分和对有序数组进行排序，拆分操作的时间复杂度为logn，排序的复杂度为n，所以归并排序的时间复杂度为O(nlogn)
- 归并排序的空间复杂度就是那个临时数组和递归时压如栈的数据占用的空间：n + logn，所以空间复杂度为O(n) 

(1)基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。归并排序中第二步，对两个有序数组排序法则非常简单，同时对两个数组的第一个位置比较大小，将小的放入一个空数组，然后被放入空数组的那个位置的指针往后移一个，然后继续和另一个数组的上一个位置进行比较，以此类推。直到最后任何一个数组先出栈完，就将另外一个数组里的所有元素追加到新数组后面。

​        归并排序和快速排序有那么点异曲同工之妙，快速排序：是先把数组粗略的排序成两个子数组，然后递归再粗略分两个子数组，直到子数组里面只有一个元素，那么就自然排好序了，可以总结为先排序再递归；归并排序：先什么都不管，把数组分为两个子数组，一直递归把数组划分为两个子数组，直到数组里只有一个元素，这时候才开始排序，让两个数组间排好序，依次按照递归的返回来把两个数组进行排好序，到最后就可以把整个数组排好序。

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201903/1647944-20190331192626448-106424413.gif)

![img](https://pic2.zhimg.com/v2-6639ef7ed441b0e2b7a71ee202e3ad05_b.jpg)

(3)实现

```java
void merge(int arr[], int l, int m, int r) 
{ 
    int i, j, k; 
    int n1 = m - l + 1; 
    int n2 =  r - m; 

    int L[n1], R[n2]; 

    for (i = 0; i < n1; i++) 
        L[i] = arr[l + i]; 
    for (j = 0; j < n2; j++) 
        R[j] = arr[m + 1+ j]; 

    i = 0; 
    j = 0; 
    k = l; 
    while (i < n1 && j < n2) 
    { 
        if (L[i] <= R[j]) 
        { 
            arr[k] = L[i]; 
            i++; 
        } 
        else
        { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 
  
    while (i < n1) 
    { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 
  
    while (j < n2) 
    { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
} 
  
void mergeSort(int arr[], int l, int r) 
{ 
    if (l < r) 
    { 
        int m = l+(r-l)/2; 
  
        mergeSort(arr, l, m); 
        mergeSort(arr, m+1, r); 
  
        merge(arr, l, m, r); 
    } 
}
```



  

# **五、基数排序**



- 时间复杂度：给定n个d位数(即d个关键码，关键码的取值范围为r)，基数排序需要比较元素的每一位，则复杂度为O(d(n+r))，其中一轮循环分配时间复杂度为O(n)，一轮循环收集时间复杂度为O(r)，共需要d次循环来进行分配收集，即时间复杂度为O(d(n+r))

(1)基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。

(2)实例

![img](https://img2018.cnblogs.com/blog/1647944/201904/1647944-20190401133403772-1355668870.png)

![img](https://img2018.cnblogs.com/blog/1647944/201904/1647944-20190401133440882-930970446.png)

(3)实现

```java
int getMax(int arr[], int n) 
{ 
    int mx = arr[0]; 
    for (int i = 1; i < n; i++) 
        if (arr[i] > mx) 
            mx = arr[i]; 
    return mx; 
} 

void countSort(int arr[], int n, int exp) 
{ 
    int output[n]; 
    int i, count[10] = {0}; 
  
    for (i = 0; i < n; i++) 
        count[ (arr[i]/exp)%10 ]++; 
  
    for (i = 1; i < 10; i++) 
        count[i] += count[i - 1]; 
  
    for (i = n - 1; i >= 0; i--) 
    { 
        output[count[ (arr[i]/exp)%10 ] - 1] = arr[i]; 
        count[ (arr[i]/exp)%10 ]--; 
    } 
  
    for (i = 0; i < n; i++) 
        arr[i] = output[i]; 
} 
  
void radixsort(int arr[], int n) 
{ 
    int m = getMax(arr, n); 
    for (int exp = 1; m/exp > 0; exp *= 10) 
        countSort(arr, n, exp); 
}
```





# 六、桶排序（Bucket Sort）

桶排序的原理是将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。

排序过程：

1. 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶
2. 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序
3. 将各个桶中的数据有序的合并起来

![img](https://img-blog.csdnimg.cn/20190219081232815.png)

代码实现：

```cpp
public static void bucketSort(int[] arr){
    
    // 计算最大值与最小值
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for(int i = 0; i < arr.length; i++){
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }
    
    // 计算桶的数量
    int bucketNum = (max - min) / arr.length + 1;
    ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);
    for(int i = 0; i < bucketNum; i++){
        bucketArr.add(new ArrayList<Integer>());
    }
    
    // 将每个元素放入桶
    for(int i = 0; i < arr.length; i++){
        int num = (arr[i] - min) / (arr.length);
        bucketArr.get(num).add(arr[i]);
    }
    
    // 对每个桶进行排序
    for(int i = 0; i < bucketArr.size(); i++){
        Collections.sort(bucketArr.get(i));
    }
    
    // 将桶中的元素赋值到原序列
	int index = 0;
	for(int i = 0; i < bucketArr.size(); i++){
		for(int j = 0; j < bucketArr.get(i).size(); j++){
			arr[index++] = bucketArr.get(i).get(j);
		}
	}  
}

```





# 二分查找

- 假设我们有 1000 万个整数数据，每个数据占 8 个字节，**如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？** 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？
  - 虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。



- 总结升华一下

  - 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。
  - 每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

- O(logn) 惊人的查找速度

  - 我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。
  -  O(logn) 这种**对数时间复杂度**。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效
    - 因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。

- 二分查找的递归与非递归实现

  - **最简单的情况**就是**有序数组中不存在重复元素**，我们在其中用二分查找值等于给定值的数据。

    - ```java
      public int bsearch(int[] a, int n, int value) {
        int low = 0;
        int high = n - 1;
       
        while (low <= high) {
          int mid = (low + high) / 2;
          if (a[mid] == value) {
            return mid;
          } else if (a[mid] < value) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
       
        return -1;
      }
      ```

    - **容易出错的 3 个地方**。

      - 1. 循环退出条件

        注意是 low<=high，而不是 low<high。

      - 2.mid 的取值

        实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会**溢出**。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成**位运算** low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。

      - 3.low 和 high 的更新

        low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生**死循环**。比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。

      - ```java
        // 二分查找的递归实现
        public int bsearch(int[] a, int n, int val) {
          return bsearchInternally(a, 0, n - 1, val);
        }
         
        private int bsearchInternally(int[] a, int low, int high, int value) {
          if (low > high) return -1;
         
          int mid =  low + ((high - low) >> 1);
          if (a[mid] == value) {
            return mid;
          } else if (a[mid] < value) {
            return bsearchInternally(a, mid+1, high, value);
          } else {
            return bsearchInternally(a, low, mid-1, value);
          }
        }
        ```

        

    - 二分查找应用场景的局限性
      - 首先，二分查找依赖的是顺序表结构，简单点说就是**数组**。
      - 那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。
      - 其次，二分查找针对的是**有序数据**。
        - 如果数据没有序，我们需要先排序。前面章节里我们讲到，排序的时间复杂度最低是 O(nlogn)。
        - 所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？
          - 二叉树
      - **数据量太小不适合二分查找**
        - 不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。
      - **数据量太大也不适合二分查找**
        - 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。
        - 注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。

-   如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢

  - 假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):
    第一次查找中间点，需要移动指针n/2次；
    第二次，需要移动指针n/4次；
    第三次需要移动指针n/8次；
    ......
    以此类推，一直到1次为值

    总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + ...+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.

    最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同  

  - 其实是查找中点的次数，数组查找中点只需要一次就可以搞定，链表需要移动 n 个元素，数组最后找到了中点，就执行了 k 次，k =logn 时间复杂度是 O(logn)，而链表找找到中点需要移动指针（n+n/2+n/4+...+n/2^k）= n-1 次, 时间复杂度是 O(n)

- 假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢

  - 现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。
  - 然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。
  - 当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。

- 变体一：查找第一个值等于给定值的元素

  - ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
          high = mid - 1;
        } else if (a[mid] < value) {
          low = mid + 1;
        } else {
     // 如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素。
    
    // 如果经过检查之后发现 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那说明此时的 a[mid] 肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在 [low, mid-1] 之间。
          if ((mid == 0) || (a[mid - 1] != value)) return mid;
          else high = mid - 1;
        }
      }
      return -1;
    }
    ```

    

- 变体二：查找最后一个值等于给定值的元素

  - ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
          high = mid - 1;
        } else if (a[mid] < value) {
          low = mid + 1;
        } else {
    // 我们还是重点看第 11 行代码。如果 a[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid] 的后一个元素 a[mid+1] 不等于 value，那也说明 a[mid] 就是我们要找的最后一个值等于给定值的元素。
    
    // 如果我们经过检查之后，发现 a[mid] 后面的一个元素 a[mid+1] 也等于 value，那说明当前的这个 a[mid] 并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在 [mid+1, high] 之间。
    
    变体三：查找第一个大于等于给定
          if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
          else low = mid + 1;
        }
      }
      return -1;
    }
    ```

    

- 变体三：查找第一个大于等于给定值的元素

  - ```java
    public int bsearch(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] >= value) {
          if ((mid == 0) || (a[mid - 1] < value)) return mid;
          else high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
      return -1;
    }
    ```

    

- 变体四：查找最后一个小于等于给定值的元素

  - ```java
    public int bsearch7(int[] a, int n, int value) {
      int low = 0;
      int high = n - 1;
      while (low <= high) {
        int mid =  low + ((high - low) >> 1);
        if (a[mid] > value) {
          high = mid - 1;
        } else {
          if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
          else low = mid + 1;
        }
      }
      return -1;
    }
    ```

    